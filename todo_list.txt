关于sweet的sequel的数据设计。

# 表示基本数据类型, Literal很重要
√ RawType: TypeAlias = Union[int | float | str | Decimal | bool | datetime | date | None | bytes | Literal]

# 增加一个Raw的class，对基本类型进行封装，让Visitor更加好处理
√ class Raw:
    v: RawType

# ArrayType类型
√ ArrayType: TypeAlias = Union[List | Tuple]

# 增加一个Array的class，对ArrayType进行封装，让Visitor更加好处理
# 注意，在 Insert xxx Values 中，Array需要用 [] 连接，其他地方用 () 连接
√ class Array:
    v: ArrayType

√ Fn + Name
   这两者很像，都可以放到Binary里面
   两者都可以做 gt，lt，... 的操作，生成 Binary

√ Binary：
   √ key、op、value
   √ Key 可以接收 RawType, Fn, Name；接收到RawType的时候，内部要转为 the Value class，方便后面的quote
   √ value 可以接收 RawType、Fn, Name 和 Array，接收到 B的时候，内部要转为 the Value class，方便后面的quote
   √ 要支持通过k=v的方式来解析Binary，可以考虑类似于：Binary.parse(username='abc')
   √ 要支持 or 和 not 和 and 操作，即：支持与或非：


√ SelectStatement：
  select_cope：
    可以是 RawType、Fn、Name。例如：select `username`；select sum(age)
    可以是 B 类型，即：基本类型。例如：select 1, 'abc'
    可以是 Array类型，但其实内部会展开，并且用 [] 连接起来？

√ InsertStatement：
   Values：可以是一个或者多个：Array，Array里面可以是 B、K 类型或者又是1个Array。
                  如果是Array的时候，最终生成quoted_str，需要用() 连接起来？。

√ Where 和 Having：
  封装了Binary的集合


 Q变成一个方法，返回Binary，供model使用

Q：封装在Where 和 Having的内部
  有很多方式能生成 Q：
  - Q(k=v)；Q(k__gt=v)
  - Name("age").eq(1)；Name("age").gt(2)
  - Fn("Sum").column(str|Name).eq(1); Fn.gt(3)





Select + Update + Delete => Where + Having => Q => Binary => Value + K + Array



# @todo: Q 里面应该使用 ValueType 和 Value
# @todo: Insert table(columns...) values() 这个地方的values方法，里面应该接受ValueType，内部转化为 ValuesList
# @todo: Update table set key=value 这个地方的key=value，应该使用ValueType，且内部需要把key=value转为Binary
# @todo: Visitor中的 visit_Value 要重构，里面要包装，不要直接用 value.v，而应该包装起来；
#        因此，对应的 quote_values_value(value: RawType) 也要重构，参数要由RawType变成Value类型
# @todo: Fn 里面有一个parentheses变量，这个变量是给 distinct用的，因为 distinct两边不用加括号，其他要加括号。但是要重构，把parentheses去掉。
# @todo: 为了让更多的Python3.x支持，需要把泛型list的地方都用 List，需要把直接用 | 的地方修改为 Union[]的方式